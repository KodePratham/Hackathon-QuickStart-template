#pragma version 10
#pragma typetrack false

// smart_contracts.piggybank.contract.PiggyBank.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1
    bytecblock "token_id" 0x151f7c75 "total_deposited" "" "is_active" "d_" "token_total_supply" "token_enabled" "goal_amount" 0x00 0x01 "project_name" "project_description" "token_name" "token_symbol" "creator"
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/piggybank/contract.py:31
    // self.project_name = String("")
    bytec 11 // "project_name"
    bytec_3 // ""
    app_global_put
    // smart_contracts/piggybank/contract.py:32
    // self.project_description = String("")
    bytec 12 // "project_description"
    bytec_3 // ""
    app_global_put
    // smart_contracts/piggybank/contract.py:33
    // self.token_id = UInt64(0)
    bytec_0 // "token_id"
    intc_0 // 0
    app_global_put
    // smart_contracts/piggybank/contract.py:34
    // self.token_name = String("")
    bytec 13 // "token_name"
    bytec_3 // ""
    app_global_put
    // smart_contracts/piggybank/contract.py:35
    // self.token_symbol = String("")
    bytec 14 // "token_symbol"
    bytec_3 // ""
    app_global_put
    // smart_contracts/piggybank/contract.py:36
    // self.token_total_supply = UInt64(0)
    bytec 6 // "token_total_supply"
    intc_0 // 0
    app_global_put
    // smart_contracts/piggybank/contract.py:37
    // self.token_enabled = UInt64(0)
    bytec 7 // "token_enabled"
    intc_0 // 0
    app_global_put
    // smart_contracts/piggybank/contract.py:38
    // self.goal_amount = UInt64(0)
    bytec 8 // "goal_amount"
    intc_0 // 0
    app_global_put
    // smart_contracts/piggybank/contract.py:39
    // self.total_deposited = UInt64(0)
    bytec_2 // "total_deposited"
    intc_0 // 0
    app_global_put
    // smart_contracts/piggybank/contract.py:40
    // self.creator = Global.zero_address
    bytec 15 // "creator"
    global ZeroAddress
    app_global_put
    // smart_contracts/piggybank/contract.py:41
    // self.is_active = Bytes(b"\x00")
    bytec 4 // "is_active"
    bytec 9 // 0x00
    app_global_put

main_after_if_else@2:
    // smart_contracts/piggybank/contract.py:5
    // class PiggyBank(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@13
    pushbytess 0xbadd14f0 0x3298e7c0 0x31214176 0xc4609b59 0x05405027 0x5c6a0aa5 0x693213c4 0x115b5daf // method "initialize_project(string,string,string,string,uint64,bool,uint64,pay)uint64", method "deposit(pay)uint64", method "withdraw(uint64)uint64", method "claim_tokens(uint64)uint64", method "opt_in_token(asset,pay)bool", method "get_project_info()(string,string,uint64,uint64,uint64,uint64)", method "get_deposit(account)uint64", method "is_goal_reached()bool"
    txna ApplicationArgs 0
    match main_initialize_project_route@5 main_deposit_route@6 main_withdraw_route@7 main_claim_tokens_route@8 main_opt_in_token_route@9 main_get_project_info_route@10 main_get_deposit_route@11 main_is_goal_reached_route@12

main_after_if_else@15:
    // smart_contracts/piggybank/contract.py:5
    // class PiggyBank(ARC4Contract):
    intc_0 // 0
    return

main_is_goal_reached_route@12:
    // smart_contracts/piggybank/contract.py:264
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub is_goal_reached
    bytec 9 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_deposit_route@11:
    // smart_contracts/piggybank/contract.py:248
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/piggybank/contract.py:5
    // class PiggyBank(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/piggybank/contract.py:248
    // @abimethod(readonly=True)
    callsub get_deposit
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_project_info_route@10:
    // smart_contracts/piggybank/contract.py:231
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_project_info
    dig 5
    len
    itob
    extract 6 2
    uncover 6
    concat
    dig 5
    len
    itob
    extract 6 2
    uncover 6
    concat
    uncover 5
    itob
    uncover 5
    itob
    uncover 5
    itob
    uncover 5
    itob
    dig 5
    len
    pushint 36 // 36
    +
    itob
    extract 6 2
    pushbytes 0x0024
    swap
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    uncover 2
    concat
    swap
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_opt_in_token_route@9:
    // smart_contracts/piggybank/contract.py:211
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/piggybank/contract.py:5
    // class PiggyBank(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/piggybank/contract.py:211
    // @abimethod()
    callsub opt_in_token
    bytec 9 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_claim_tokens_route@8:
    // smart_contracts/piggybank/contract.py:175
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/piggybank/contract.py:5
    // class PiggyBank(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/piggybank/contract.py:175
    // @abimethod()
    callsub claim_tokens
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_withdraw_route@7:
    // smart_contracts/piggybank/contract.py:146
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/piggybank/contract.py:5
    // class PiggyBank(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/piggybank/contract.py:146
    // @abimethod()
    callsub withdraw
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_deposit_route@6:
    // smart_contracts/piggybank/contract.py:122
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/piggybank/contract.py:5
    // class PiggyBank(ARC4Contract):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/piggybank/contract.py:122
    // @abimethod()
    callsub deposit
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_initialize_project_route@5:
    // smart_contracts/piggybank/contract.py:43
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/piggybank/contract.py:5
    // class PiggyBank(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    extract 2 0
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    intc_0 // 0
    getbit
    txna ApplicationArgs 7
    btoi
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/piggybank/contract.py:43
    // @abimethod()
    callsub initialize_project
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@13:
    // smart_contracts/piggybank/contract.py:5
    // class PiggyBank(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@15
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts.piggybank.contract.PiggyBank.initialize_project(name: bytes, description: bytes, token_name: bytes, token_symbol: bytes, token_supply: uint64, token_enabled: uint64, goal: uint64, mbr_pay: uint64) -> uint64:
initialize_project:
    // smart_contracts/piggybank/contract.py:43-54
    // @abimethod()
    // def initialize_project(
    //     self,
    //     name: String,
    //     description: String,
    //     token_name: String,
    //     token_symbol: String,
    //     token_supply: UInt64,
    //     token_enabled: bool,
    //     goal: UInt64,
    //     mbr_pay: gtxn.PaymentTransaction,
    // ) -> UInt64:
    proto 8 1
    // smart_contracts/piggybank/contract.py:71-72
    // # Ensure project hasn't been initialized yet
    // assert self.is_active == Bytes(b"\x00"), "Project already initialized"
    intc_0 // 0
    bytec 4 // "is_active"
    app_global_get_ex
    assert // check self.is_active exists
    bytec 9 // 0x00
    ==
    assert // Project already initialized
    // smart_contracts/piggybank/contract.py:74-75
    // # Validate MBR payment
    // assert mbr_pay.receiver == Global.current_application_address, "Payment must be to contract"
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Payment must be to contract
    // smart_contracts/piggybank/contract.py:76
    // if token_enabled:
    frame_dig -3
    bz initialize_project_after_if_else@2
    // smart_contracts/piggybank/contract.py:77
    // assert mbr_pay.amount >= 200000, "Insufficient MBR payment"  # 0.2 ALGO for ASA creation
    frame_dig -1
    gtxns Amount
    pushint 200000 // 200000
    >=
    assert // Insufficient MBR payment

initialize_project_after_if_else@2:
    // smart_contracts/piggybank/contract.py:79-80
    // # Set project details
    // self.project_name = name
    bytec 11 // "project_name"
    frame_dig -8
    app_global_put
    // smart_contracts/piggybank/contract.py:81
    // self.project_description = description
    bytec 12 // "project_description"
    frame_dig -7
    app_global_put
    // smart_contracts/piggybank/contract.py:82
    // self.goal_amount = goal
    bytec 8 // "goal_amount"
    frame_dig -2
    app_global_put
    // smart_contracts/piggybank/contract.py:83
    // self.creator = Txn.sender
    bytec 15 // "creator"
    txn Sender
    app_global_put
    // smart_contracts/piggybank/contract.py:84
    // self.is_active = Bytes(b"\x01")
    bytec 4 // "is_active"
    bytec 10 // 0x01
    app_global_put
    // smart_contracts/piggybank/contract.py:85
    // self.token_enabled = UInt64(1) if token_enabled else UInt64(0)
    bytec 7 // "token_enabled"
    frame_dig -3
    app_global_put
    // smart_contracts/piggybank/contract.py:87
    // if token_enabled:
    frame_dig -3
    bz initialize_project_else_body@5
    // smart_contracts/piggybank/contract.py:88
    // assert token_name.bytes.length > 0, "Token name is required"
    frame_dig -6
    len
    dup
    assert // Token name is required
    // smart_contracts/piggybank/contract.py:89
    // assert token_name.bytes.length <= 32, "Token name must be <= 32 bytes"
    pushint 32 // 32
    <=
    assert // Token name must be <= 32 bytes
    // smart_contracts/piggybank/contract.py:90
    // assert token_symbol.bytes.length > 0, "Token symbol is required"
    frame_dig -5
    len
    dup
    assert // Token symbol is required
    // smart_contracts/piggybank/contract.py:91
    // assert token_symbol.bytes.length <= 8, "Token symbol must be <= 8 bytes"
    pushint 8 // 8
    <=
    assert // Token symbol must be <= 8 bytes
    // smart_contracts/piggybank/contract.py:93
    // self.token_name = token_name
    bytec 13 // "token_name"
    frame_dig -6
    app_global_put
    // smart_contracts/piggybank/contract.py:94
    // self.token_symbol = token_symbol
    bytec 14 // "token_symbol"
    frame_dig -5
    app_global_put
    // smart_contracts/piggybank/contract.py:95
    // self.token_total_supply = token_supply
    bytec 6 // "token_total_supply"
    frame_dig -4
    app_global_put
    // smart_contracts/piggybank/contract.py:98-110
    // itxn.AssetConfig(
    //     total=token_supply,
    //     decimals=6,
    //     unit_name=token_symbol,
    //     asset_name=token_name,
    //     url="ipfs://",
    //     manager=Txn.sender,
    //     reserve=Txn.sender,
    //     freeze=Txn.sender,
    //     clawback=Txn.sender,
    //     fee=0,
    // )
    // .submit()
    itxn_begin
    // smart_contracts/piggybank/contract.py:104
    // manager=Txn.sender,
    txn Sender
    // smart_contracts/piggybank/contract.py:105-107
    // reserve=Txn.sender,
    // freeze=Txn.sender,
    // clawback=Txn.sender,
    dupn 3
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetFreeze
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    // smart_contracts/piggybank/contract.py:103
    // url="ipfs://",
    pushbytes "ipfs://"
    itxn_field ConfigAssetURL
    frame_dig -6
    itxn_field ConfigAssetName
    frame_dig -5
    itxn_field ConfigAssetUnitName
    // smart_contracts/piggybank/contract.py:100
    // decimals=6,
    pushint 6 // 6
    itxn_field ConfigAssetDecimals
    frame_dig -4
    itxn_field ConfigAssetTotal
    // smart_contracts/piggybank/contract.py:98
    // itxn.AssetConfig(
    pushint 3 // acfg
    itxn_field TypeEnum
    // smart_contracts/piggybank/contract.py:108
    // fee=0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/piggybank/contract.py:98-110
    // itxn.AssetConfig(
    //     total=token_supply,
    //     decimals=6,
    //     unit_name=token_symbol,
    //     asset_name=token_name,
    //     url="ipfs://",
    //     manager=Txn.sender,
    //     reserve=Txn.sender,
    //     freeze=Txn.sender,
    //     clawback=Txn.sender,
    //     fee=0,
    // )
    // .submit()
    itxn_submit
    // smart_contracts/piggybank/contract.py:113
    // self.token_id = token.created_asset.id
    bytec_0 // "token_id"
    itxn CreatedAssetID
    app_global_put

initialize_project_after_if_else@6:
    // smart_contracts/piggybank/contract.py:120
    // return self.token_id
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    retsub

initialize_project_else_body@5:
    // smart_contracts/piggybank/contract.py:115
    // self.token_name = String("")
    bytec 13 // "token_name"
    bytec_3 // ""
    app_global_put
    // smart_contracts/piggybank/contract.py:116
    // self.token_symbol = String("")
    bytec 14 // "token_symbol"
    bytec_3 // ""
    app_global_put
    // smart_contracts/piggybank/contract.py:117
    // self.token_total_supply = UInt64(0)
    bytec 6 // "token_total_supply"
    intc_0 // 0
    app_global_put
    // smart_contracts/piggybank/contract.py:118
    // self.token_id = UInt64(0)
    bytec_0 // "token_id"
    intc_0 // 0
    app_global_put
    b initialize_project_after_if_else@6


// smart_contracts.piggybank.contract.PiggyBank.deposit(pay_txn: uint64) -> uint64:
deposit:
    // smart_contracts/piggybank/contract.py:122-123
    // @abimethod()
    // def deposit(self, pay_txn: gtxn.PaymentTransaction) -> UInt64:
    proto 1 1
    // smart_contracts/piggybank/contract.py:133
    // assert self.is_active == Bytes(b"\x01"), "Project not active"
    intc_0 // 0
    bytec 4 // "is_active"
    app_global_get_ex
    assert // check self.is_active exists
    bytec 10 // 0x01
    ==
    assert // Project not active
    // smart_contracts/piggybank/contract.py:134
    // assert pay_txn.receiver == Global.current_application_address, "Receiver must be the contract"
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Receiver must be the contract
    // smart_contracts/piggybank/contract.py:135
    // assert pay_txn.amount > 0, "Deposit amount must be greater than zero"
    frame_dig -1
    gtxns Amount
    dup
    assert // Deposit amount must be greater than zero
    // smart_contracts/piggybank/contract.py:137
    // amount, exists = self.deposits.maybe(pay_txn.sender)
    frame_dig -1
    gtxns Sender
    bytec 5 // "d_"
    swap
    concat
    dup
    box_get
    swap
    btoi
    swap
    // smart_contracts/piggybank/contract.py:138
    // if exists:
    bz deposit_else_body@2
    // smart_contracts/piggybank/contract.py:139
    // self.deposits[pay_txn.sender] = amount + pay_txn.amount
    frame_dig 2
    frame_dig 0
    +
    itob
    frame_dig 1
    swap
    box_put

deposit_after_if_else@3:
    // smart_contracts/piggybank/contract.py:143
    // self.total_deposited += pay_txn.amount
    intc_0 // 0
    bytec_2 // "total_deposited"
    app_global_get_ex
    assert // check self.total_deposited exists
    frame_dig 0
    +
    bytec_2 // "total_deposited"
    swap
    app_global_put
    // smart_contracts/piggybank/contract.py:144
    // return self.deposits[pay_txn.sender]
    frame_dig 1
    box_get
    swap
    btoi
    swap
    assert // check self.deposits entry exists
    frame_bury 0
    retsub

deposit_else_body@2:
    // smart_contracts/piggybank/contract.py:141
    // self.deposits[pay_txn.sender] = pay_txn.amount
    frame_dig 0
    itob
    frame_dig 1
    swap
    box_put
    b deposit_after_if_else@3


// smart_contracts.piggybank.contract.PiggyBank.withdraw(amount: uint64) -> uint64:
withdraw:
    // smart_contracts/piggybank/contract.py:146-147
    // @abimethod()
    // def withdraw(self, amount: UInt64) -> UInt64:
    proto 1 1
    // smart_contracts/piggybank/contract.py:157
    // assert self.is_active == Bytes(b"\x01"), "Project not active"
    intc_0 // 0
    bytec 4 // "is_active"
    app_global_get_ex
    assert // check self.is_active exists
    bytec 10 // 0x01
    ==
    assert // Project not active
    // smart_contracts/piggybank/contract.py:158
    // current, exists = self.deposits.maybe(Txn.sender)
    bytec 5 // "d_"
    txn Sender
    concat
    box_get
    swap
    btoi
    // smart_contracts/piggybank/contract.py:159
    // assert exists, "No deposits found for this account"
    swap
    assert // No deposits found for this account
    // smart_contracts/piggybank/contract.py:160
    // assert amount > 0, "Withdrawal amount must be greater than zero"
    frame_dig -1
    assert // Withdrawal amount must be greater than zero
    // smart_contracts/piggybank/contract.py:161
    // assert amount <= current, "Withdrawal amount exceeds balance"
    frame_dig -1
    dig 1
    <=
    assert // Withdrawal amount exceeds balance
    // smart_contracts/piggybank/contract.py:163
    // itxn.Payment(receiver=Txn.sender, amount=amount, fee=0).submit()
    itxn_begin
    txn Sender
    frame_dig -1
    itxn_field Amount
    itxn_field Receiver
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/piggybank/contract.py:165
    // remaining = current - amount
    frame_dig -1
    -
    dup
    // smart_contracts/piggybank/contract.py:166
    // self.total_deposited -= amount
    intc_0 // 0
    bytec_2 // "total_deposited"
    app_global_get_ex
    assert // check self.total_deposited exists
    frame_dig -1
    -
    bytec_2 // "total_deposited"
    swap
    app_global_put
    // smart_contracts/piggybank/contract.py:168
    // if remaining == UInt64(0):
    bnz withdraw_else_body@3
    // smart_contracts/piggybank/contract.py:169
    // del self.deposits[Txn.sender]
    bytec 5 // "d_"
    txn Sender
    concat
    box_del
    pop

withdraw_after_if_else@4:
    // smart_contracts/piggybank/contract.py:173
    // return remaining
    frame_dig 0
    swap
    retsub

withdraw_else_body@3:
    // smart_contracts/piggybank/contract.py:171
    // self.deposits[Txn.sender] = remaining
    bytec 5 // "d_"
    txn Sender
    concat
    frame_dig 0
    itob
    box_put
    b withdraw_after_if_else@4


// smart_contracts.piggybank.contract.PiggyBank.claim_tokens(token_amount: uint64) -> uint64:
claim_tokens:
    // smart_contracts/piggybank/contract.py:175-176
    // @abimethod()
    // def claim_tokens(self, token_amount: UInt64) -> UInt64:
    proto 1 1
    // smart_contracts/piggybank/contract.py:187
    // assert self.is_active == Bytes(b"\x01"), "Project not active"
    intc_0 // 0
    bytec 4 // "is_active"
    app_global_get_ex
    assert // check self.is_active exists
    bytec 10 // 0x01
    ==
    assert // Project not active
    // smart_contracts/piggybank/contract.py:188
    // assert self.token_enabled == UInt64(1), "Token is disabled for this project"
    intc_0 // 0
    bytec 7 // "token_enabled"
    app_global_get_ex
    assert // check self.token_enabled exists
    intc_1 // 1
    ==
    assert // Token is disabled for this project
    // smart_contracts/piggybank/contract.py:189
    // assert self.token_id > 0, "Token not created yet"
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    assert // Token not created yet
    // smart_contracts/piggybank/contract.py:191
    // max_claimable = self.token_total_supply
    intc_0 // 0
    bytec 6 // "token_total_supply"
    app_global_get_ex
    assert // check self.token_total_supply exists
    // smart_contracts/piggybank/contract.py:192
    // if Txn.sender != self.creator:
    txn Sender
    intc_0 // 0
    bytec 15 // "creator"
    app_global_get_ex
    assert // check self.creator exists
    !=
    bz claim_tokens_after_if_else@2
    // smart_contracts/piggybank/contract.py:193
    // current_deposit, exists = self.deposits.maybe(Txn.sender)
    bytec 5 // "d_"
    txn Sender
    concat
    box_get
    swap
    btoi
    // smart_contracts/piggybank/contract.py:194
    // assert exists, "No deposits found for this account"
    swap
    assert // No deposits found for this account
    // smart_contracts/piggybank/contract.py:195
    // assert current_deposit > 0, "No deposits to claim tokens for"
    dup
    assert // No deposits to claim tokens for
    // smart_contracts/piggybank/contract.py:197-198
    // # Simple token distribution: 1 token per 1000 microAlgos deposited
    // max_claimable = current_deposit // 1000
    pushint 1000 // 1000
    /
    frame_bury 0

claim_tokens_after_if_else@2:
    // smart_contracts/piggybank/contract.py:199
    // assert token_amount <= max_claimable, "Claiming more than allowed"
    frame_dig -1
    frame_dig 0
    <=
    assert // Claiming more than allowed
    // smart_contracts/piggybank/contract.py:201-207
    // # Transfer tokens to sender
    // itxn.AssetTransfer(
    //     asset_receiver=Txn.sender,
    //     asset_amount=token_amount,
    //     xfer_asset=self.token_id,
    //     fee=0,
    // ).submit()
    itxn_begin
    // smart_contracts/piggybank/contract.py:203
    // asset_receiver=Txn.sender,
    txn Sender
    // smart_contracts/piggybank/contract.py:205
    // xfer_asset=self.token_id,
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    itxn_field XferAsset
    frame_dig -1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    // smart_contracts/piggybank/contract.py:201-202
    // # Transfer tokens to sender
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    // smart_contracts/piggybank/contract.py:206
    // fee=0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/piggybank/contract.py:201-207
    // # Transfer tokens to sender
    // itxn.AssetTransfer(
    //     asset_receiver=Txn.sender,
    //     asset_amount=token_amount,
    //     xfer_asset=self.token_id,
    //     fee=0,
    // ).submit()
    itxn_submit
    // smart_contracts/piggybank/contract.py:209
    // return token_amount
    frame_dig -1
    swap
    retsub


// smart_contracts.piggybank.contract.PiggyBank.opt_in_token(asset: uint64, mbr_pay: uint64) -> uint64:
opt_in_token:
    // smart_contracts/piggybank/contract.py:211-212
    // @abimethod()
    // def opt_in_token(self, asset: Asset, mbr_pay: gtxn.PaymentTransaction) -> bool:
    proto 2 1
    // smart_contracts/piggybank/contract.py:224
    // assert mbr_pay.receiver == Global.current_application_address, "Payment must be to contract"
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Payment must be to contract
    // smart_contracts/piggybank/contract.py:225
    // assert mbr_pay.amount >= 100000, "Insufficient MBR payment"
    frame_dig -1
    gtxns Amount
    pushint 100000 // 100000
    >=
    assert // Insufficient MBR payment
    // smart_contracts/piggybank/contract.py:226
    // assert self.token_enabled == UInt64(1), "Token is disabled for this project"
    intc_0 // 0
    bytec 7 // "token_enabled"
    app_global_get_ex
    assert // check self.token_enabled exists
    intc_1 // 1
    ==
    assert // Token is disabled for this project
    // smart_contracts/piggybank/contract.py:227
    // assert asset.id == self.token_id, "Invalid token"
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    frame_dig -2
    ==
    assert // Invalid token
    // smart_contracts/piggybank/contract.py:229
    // return True
    intc_1 // 1
    retsub


// smart_contracts.piggybank.contract.PiggyBank.get_project_info() -> bytes, bytes, uint64, uint64, uint64, uint64:
get_project_info:
    // smart_contracts/piggybank/contract.py:240
    // self.project_name,
    intc_0 // 0
    bytec 11 // "project_name"
    app_global_get_ex
    assert // check self.project_name exists
    // smart_contracts/piggybank/contract.py:241
    // self.project_description,
    intc_0 // 0
    bytec 12 // "project_description"
    app_global_get_ex
    assert // check self.project_description exists
    // smart_contracts/piggybank/contract.py:242
    // self.token_id,
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    // smart_contracts/piggybank/contract.py:243
    // self.goal_amount,
    intc_0 // 0
    bytec 8 // "goal_amount"
    app_global_get_ex
    assert // check self.goal_amount exists
    // smart_contracts/piggybank/contract.py:244
    // self.total_deposited,
    intc_0 // 0
    bytec_2 // "total_deposited"
    app_global_get_ex
    assert // check self.total_deposited exists
    // smart_contracts/piggybank/contract.py:245
    // self.token_total_supply,
    intc_0 // 0
    bytec 6 // "token_total_supply"
    app_global_get_ex
    assert // check self.token_total_supply exists
    // smart_contracts/piggybank/contract.py:239-246
    // return (
    //     self.project_name,
    //     self.project_description,
    //     self.token_id,
    //     self.goal_amount,
    //     self.total_deposited,
    //     self.token_total_supply,
    // )
    retsub


// smart_contracts.piggybank.contract.PiggyBank.get_deposit(account: bytes) -> uint64:
get_deposit:
    // smart_contracts/piggybank/contract.py:248-249
    // @abimethod(readonly=True)
    // def get_deposit(self, account: Account) -> UInt64:
    proto 1 1
    // smart_contracts/piggybank/contract.py:259
    // amount, exists = self.deposits.maybe(account)
    bytec 5 // "d_"
    frame_dig -1
    concat
    box_get
    swap
    btoi
    swap
    // smart_contracts/piggybank/contract.py:260
    // if exists:
    bz get_deposit_after_if_else@2
    // smart_contracts/piggybank/contract.py:261
    // return amount
    frame_dig 0
    swap
    retsub

get_deposit_after_if_else@2:
    // smart_contracts/piggybank/contract.py:262
    // return UInt64(0)
    intc_0 // 0
    swap
    retsub


// smart_contracts.piggybank.contract.PiggyBank.is_goal_reached() -> uint64:
is_goal_reached:
    // smart_contracts/piggybank/contract.py:267
    // return self.total_deposited >= self.goal_amount
    intc_0 // 0
    bytec_2 // "total_deposited"
    app_global_get_ex
    assert // check self.total_deposited exists
    intc_0 // 0
    bytec 8 // "goal_amount"
    app_global_get_ex
    assert // check self.goal_amount exists
    >=
    retsub
